(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{415:function(_,v,e){"use strict";e.r(v);var o=e(3),c=Object(o.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-回调地狱"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-回调地狱"}},[_._v("#")]),_._v(" 1.回调地狱")]),_._v(" "),v("p",[v("code",[_._v("多层回调函数的相互嵌套")]),_._v("，就形成了"),v("code",[_._v("回调地狱")]),_._v("。")]),_._v(" "),v("p",[_._v("回调地狱的缺点：")]),_._v(" "),v("ul",[v("li",[_._v("代码耦合性太强，牵一发而动全身，"),v("code",[_._v("难以维护")])]),_._v(" "),v("li",[_._v("大量冗余的代码相互嵌套，代码的"),v("code",[_._v("可读性变差")])])]),_._v(" "),v("p",[_._v("为了解决回调地狱的问题，"),v("code",[_._v("ES6（ECMAScript 2015）")]),_._v("中新增了 "),v("code",[_._v("Promise")]),_._v(" 的概念。")]),_._v(" "),v("h2",{attrs:{id:"_2-promise-的基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise-的基本概念"}},[_._v("#")]),_._v(" 2.Promise 的基本概念")]),_._v(" "),v("p",[v("strong",[_._v("1."),v("code",[_._v("Promise")]),_._v(" 是一个构造函数")])]),_._v(" "),v("ul",[v("li",[_._v("我们可以创建 "),v("code",[_._v("Promise")]),_._v(" 的实例 "),v("code",[_._v("const p = new Promise()")])]),_._v(" "),v("li",[v("code",[_._v("new")]),_._v(" 出来的 "),v("code",[_._v("Promise")]),_._v(" 实例对象，代表一个异步操作")])]),_._v(" "),v("p",[v("strong",[_._v("2."),v("code",[_._v("Promise.prototype")]),_._v(" 上包含一个 "),v("code",[_._v(".then()")]),_._v(" 方法")])]),_._v(" "),v("ul",[v("li",[_._v("每一次 "),v("code",[_._v("new Promise()")]),_._v(" 构造函数得到的实例对象")]),_._v(" "),v("li",[_._v("都可以通过"),v("code",[_._v("原型链的方式")]),_._v("访问到 "),v("code",[_._v(".then()")]),_._v(" 方法，例如 "),v("code",[_._v("p.then()")])])]),_._v(" "),v("p",[v("strong",[_._v("3."),v("code",[_._v(".then()")]),_._v(" 方法用来预先指定成功和失败的回调函数")])]),_._v(" "),v("ul",[v("li",[_._v("p.then("),v("code",[_._v("成功的回调函数")]),_._v("，"),v("code",[_._v("失败的回调函数")]),_._v(")")]),_._v(" "),v("li",[_._v("p.then("),v("code",[_._v("result")]),_._v(" => { }, "),v("code",[_._v("error")]),_._v(" => { })")]),_._v(" "),v("li",[_._v("调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的")])]),_._v(" "),v("p",[v("strong",[_._v("4."),v("code",[_._v(".then()")]),_._v(" 方法的特性")])]),_._v(" "),v("p",[_._v("如果上一个 "),v("code",[_._v(".then()")]),_._v(" 方法中返回了一个新的 "),v("code",[_._v("Promise")]),_._v(" 实例对象，则可以通过下一个 "),v("code",[_._v(".then()")]),_._v("继续进行处理。通\n过 "),v("code",[_._v(".then()")]),_._v(" 方法的链式调用，就解决了回调地狱的问题。")]),_._v(" "),v("p",[v("strong",[_._v("5.通过 "),v("code",[_._v(".catch")]),_._v(" 捕获错误")])]),_._v(" "),v("ul",[v("li",[_._v("在 "),v("code",[_._v("Promise")]),_._v(" 的链式操作中如果发生了错误，可以使用 "),v("code",[_._v("Promise.prototype.catch")]),_._v(" 方法进行捕获和处理")]),_._v(" "),v("li",[_._v("如果不希望前面的错误导致后续的 "),v("code",[_._v(".then")]),_._v(" 无法正常执行，则可以将 "),v("code",[_._v(".catch")]),_._v(" 的调用提前")])]),_._v(" "),v("p",[v("strong",[_._v("6. "),v("code",[_._v("Promise.all()")]),_._v(" 方法")])]),_._v(" "),v("p",[v("code",[_._v("Promise.all()")]),_._v(" 方法会发起并行的 "),v("code",[_._v("Promise")]),_._v(" 异步操作，等"),v("code",[_._v("所有的异步操作全部结束后")]),_._v("才会执行下一步的 "),v("code",[_._v(".then")]),_._v("\n操作（等待机制）")]),_._v(" "),v("p",[v("strong",[_._v("7. "),v("code",[_._v("Promise.race()")]),_._v(" 方法")])]),_._v(" "),v("p",[v("code",[_._v("Promise.race()")]),_._v(" 方法会发起并行的 "),v("code",[_._v("Promise")]),_._v(" 异步操作，"),v("code",[_._v("只要任何一个异步操作完成，就立即执行下一步的.then 操作")]),_._v("（赛跑机制）")])])}),[],!1,null,null,null);v.default=c.exports}}]);